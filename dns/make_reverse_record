#!/bin/env ruby
# frozen_string_literal: true
#
# make rverse record v1.0
#
# The MIT License
# Copyright (c) 2018 Kyoto University of Education
# https://opensource.org/licenses/MIT

require 'ipaddr'
require 'yaml'

class ReverseRecord
  def initialize(ip)
    ip = IPAddr.new(ip) unless ip.is_a?(IPAddr)
    @ip = ip
    @netmask = get_netmask(ip)
    @ptrs = {}
    @full_domain = @ip.reverse

    if @ip.ipv4?
      raise "invalid ipv4 netmask: #{@netmask}" unless (@netmask % 8).zero?
      subdomain_num = (32 - @netmask) / 8
    else
      raise "invalid ipv6 netmask: #{@netmask}" unless (@netmask % 4).zero?
      subdomain_num = (128 - @netmask) / 4
    end
    start_net_domain = '0.' * subdomain_num
    unless @full_domain.start_with?(start_net_domain)
      raise "invalid full domain name: #{@full_domain}"
    end
    @domain = @full_domain.sub(start_net_domain, '')
  end

  def include?(ip)
    @ip.include?(ip)
  end
  alias :=== :include?

  def get_netmask(ip)
    ip_range = ip.to_range
    num = ip_range.last.to_i - ip_range.first.to_i + 1
    num_bit = Math.log2(num).to_i
    if ip.ipv4?
      32 - num_bit
    else
      128 - num_bit
    end
  end

  def header(zone_info)
    header_str = <<EndOfHeader
; generated by make_reverse_record #{Time.now}
$TTL\t#{zone_info[:ttl]}
@\tIN\tSOA\t#{zone_info[:soa][:ns]} #{zone_info[:soa][:mail]} (
\t\t\t#{zone_info[:soa][:serial]}\t; Serial
\t\t\t#{zone_info[:soa][:reflesh]}\t\t; Reflesh
\t\t\t#{zone_info[:soa][:retry]}\t\t; Retry
\t\t\t#{zone_info[:soa][:expire]}\t\t; Expire
\t\t\t#{zone_info[:soa][:minimum]}\t)\t; Minimum
EndOfHeader
    zone_info[:ns_list].each do |ns|
      header_str += "@\tIN\tNS\t#{ns}\n"
    end
    header_str
  end

  def add(ip, host)
    unless @ip.include?(ip)
      raise "out range ip: #{ip}"
    end
    if @ptrs.has_key?(ip)
      raise "duplicated ip: #{ip}"
    end
    @ptrs[ip] = Ptr.new(ip, host)
  end

  def to_record(serial)
    header(serial) +
      "\n" +
      @ptrs.keys.sort.map do |key|
        @ptrs[key].to_record(@domain)
      end.join("\n") +
      "\n"
  end

  def file_name
    if @ip.ipv4?
      name = @ip.to_s.sub(/(?:\.0)*$/, '')
    else
      name = @ip.to_s.tr(':', '_').sub(/__$/, '')
    end
    "#{name}.rev"
  end

  class Ptr
    attr_reader :ip, :host
    def initialize(ip, host)
      ip = IPAddr.new(ip) unless ip.is_a?(IPAddr)
      @ip = ip
      @host = host
    end

    def to_record(domain = nil)
      name = @ip.reverse
      if domain && name.end_with?(".#{domain}")
        name = name.sub(".#{domain}", '')
      else
        name += '.' unless name.end_with?('.')
      end
      value = @host
      value += '.' unless value.end_with?('.')
      "#{name}\tIN\tPTR\t#{value}"
    end
  end
end

class ZoneFile
  def initialize(domain, file)
    @domain = domain
    @file = file
    @data = IO.read(file)
    @a_list = []
    parse
  end

  def parse
    @serial = nil
    @data.each_line do |line|
      case line
      when /^\s+(\d+)\s*;\s*serial\s*$/i
        raise "duplicate serial: #{line.chomp}" if @serial
        @serial = $1.to_i
      when /^(\S+)\s+(\d+\s+)?IN\s+A\s+([\d.]+)\s*(;.*)?$/,
        /^(\S+)\s+(\d+\s+)?IN\s+AAAA\s+([\da-fA-F:]+)\s*(;.*)?$/
        name = $1
        _ttl = $2.to_i
        ip = $3
        comment = $4.to_s
        if /(?:no\s+|!\s*)(ptr)/i =~ comment
          # puts "skip: #{line.chomp}"
          next
        end
        if name.include?('*')
          # puts "skip: #{line.chomp}"
          next
        end
        if name == '@'
          name = @domain
        elsif name.end_with?('.')
          name = name.sub(/\.$/, '')
        else
          name = "#{name}.#{@domain}"
        end
        @a_list << {
          host: name,
          ip: ip,
        }
      end
    end
  end

  def serial
    @serial
  end

  def a_each(&block)
    @a_list.each(&block)
  end
end

if $0 == __FILE__
  config = YAML.load(IO.read(File.join(__dir__, 'make_reverse_record.yml')))

  reverse_list = config['ip_list'].map do |ip_str|
    ReverseRecord.new(ip_str)
  end

  zone_list = config['zone_list'].map do |zone|
    ZoneFile.new(zone['domain'], zone['file'])
  end
  serial = zone_list.map(&:serial).max
  zone_info = {
    ttl: config['zone_info']['ttl'] || 86400,
    soa: {
      ns: config['zone_info']['soa']['ns'],
      mail: config['zone_info']['soa']['mail'],
      serial: serial,
      reflesh: config['zone_info']['soa']['reflesh'] || 10800,
      retry: config['zone_info']['soa']['retry'] || 3600,
      expire: config['zone_info']['soa']['expire'] || 3600000,
      minimum: config['zone_info']['soa']['minimum'] || 86400,
    },
    ns_list: config['zone_info']['ns_list'],
  }

  zone_list.each do |zone|
    zone.a_each do |a|
      ip = IPAddr.new(a[:ip])
      reverse_list.any? do |reverse|
        if reverse.include?(ip)
          begin
            reverse.add(ip, a[:host])
          rescue => e
            raise "fail to add, becaus by #{e} : #{a}"
          end
          true
        else
          false
        end
      end
    end
  end

  reverse_list.each do |reverse|
    File.open(config['save_dir'] + '/' + reverse.file_name, 'w') do |io|
      io.write(reverse.to_record(zone_info))
    end
  end
  puts "success"
end
